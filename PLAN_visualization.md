# Plan: Interactive Seam Carving Visualization (HTML/JS)

## Context

We've implemented "carving the mapping" (Section 3.3) and seam pairs (Section 3.6) —
41 tests passing. Now we need a way to **visually verify** and **interactively explore**
the results. The user wants a self-contained HTML/JS web UI generated by a Python script.

Test images: `bagel.jpg` (real photo) and `output/test_river.png` (synthetic river scene).

## Architecture

**Python script** (`examples/generate_visualization.py`) that:
1. Runs the carving pipeline on both test images
2. Captures all intermediate data per seam iteration (energy maps, lattice-space images,
   seam positions, carved results)
3. Encodes everything as base64 PNGs
4. Generates a single self-contained `output/visualization.html` with embedded JS

**No server needed** — just `python generate_visualization.py` then open the HTML file.

## What the HTML shows

### Main panels (always visible):
1. **Original image** — with seam overlay (red line showing current seam in world space)
2. **Carved result** — the image after N seams, updated via slider

### Controls:
- **Image selector** — toggle between bagel and river images
- **Seam count slider** — scrub from 0 to max_seams, see result update per-step
- **Mode toggle** — "Standard carving" vs "Seam pairs" (for bagel: ROI = bagel hole
  region, pair = background region)

### Lattice detail panel (toggleable, like Figure 12 in paper):
- **Unrolled lattice image** — the rectified image in lattice index space
- **Energy map** — gradient magnitude in lattice space (heatmap colorized)
- **Seam overlay on lattice** — the greedy seam drawn on the unrolled energy/image
- All three update per iteration step

### Layout:
```
┌─────────────────────────────────────────────────┐
│ [Image: bagel ▼ river]  [Mode: standard ▼ pairs]│
│                                                  │
│  ┌──────────────┐    ┌──────────────┐           │
│  │  Original +   │    │   Carved     │           │
│  │  seam overlay │    │   result     │           │
│  └──────────────┘    └──────────────┘           │
│                                                  │
│  Seams: [=====|================] 5 / 30          │
│                                                  │
│  [✓] Show lattice details                        │
│  ┌────────────┐ ┌────────────┐ ┌────────────┐  │
│  │ Unrolled   │ │  Energy    │ │ Lattice +  │  │
│  │ lattice    │ │  heatmap   │ │ seam       │  │
│  └────────────┘ └────────────┘ └────────────┘  │
└─────────────────────────────────────────────────┘
```

## Python script structure (`examples/generate_visualization.py`)

### Data collection function:
```python
def collect_carving_data(image, lattice, n_seams, lattice_width, mode='standard',
                         roi_range=None, pair_range=None):
    """Run carving and collect all intermediate visualizations.

    Returns list of dicts (one per iteration):
        {
            'world_energy': tensor,      # energy map in world space
            'lattice_energy': tensor,    # energy map in lattice space
            'lattice_image': tensor,     # unrolled image in lattice space
            'seam': tensor,              # seam indices in lattice space
            'pair_seam': tensor | None,  # pair seam (if seam pairs mode)
            'result': tensor,            # carved image after this step
        }
    """
```

This function mirrors `carve_image_lattice_guided` / `carve_seam_pairs` but saves
intermediates instead of discarding them.

### Image encoding:
- Convert each tensor to PNG bytes via PIL → base64 string
- Energy maps: normalize to [0,1], apply a colormap (matplotlib `inferno`), encode
- Seam overlays: draw red line on lattice energy image, encode
- World-space seam: use `_interpolate_seam` + `inverse_mapping` to draw seam on original

### HTML generation:
- Template string with embedded CSS/JS
- All image data as a JS object: `const DATA = { bagel: { standard: [...], pairs: [...] }, river: { standard: [...] } }`
- Each entry is `{ original: "data:image/png;base64,...", result: "...", lattice: "...", energy: "...", seamOnLattice: "..." }`
- JS swaps `<img>` sources based on slider/selector state
- CSS grid layout, minimal styling

### Configuration per image:
- **Bagel**: rectangular lattice, `n_seams=30`, for pairs mode: ROI ~bagel hole columns,
  pair ~right background
- **River**: rectangular lattice, `n_seams=30`

## Animated GIF output (demo artifact)

Generate `output/seam_pairs_animation.gif` showing the seam pairs algorithm iterating:
- Each frame shows the current image with:
  - ROI seam overlaid in **red** (shrinking region)
  - Pair seam overlaid in **green** (expanding region)
  - Semi-transparent highlight on the ROI and pair windows
- The image visibly morphs each frame as content compresses/expands
- ~30 frames (one per seam pair), ~200ms per frame
- Good for sharing / README embedding

Generated by the same Python script alongside the HTML visualization.

## File changes

### New file: `examples/generate_visualization.py`
- `collect_carving_data()` — runs pipeline, captures intermediates
- `tensor_to_base64()` — converts tensor → base64 PNG string
- `energy_to_base64()` — converts energy tensor → colormapped base64 PNG
- `draw_seam_on_image()` — overlays seam as red line on image tensor
- `draw_seam_on_lattice()` — overlays seam on lattice-space image
- `generate_html()` — assembles HTML string from collected data
- `main()` — loads images, runs both modes, generates HTML

### No changes to src/ — this is purely a visualization consumer.

## Verification

```bash
conda run -n lattice-carving python examples/generate_visualization.py
# Should produce output/visualization.html
# Open in browser to verify interactive controls work
```

Check:
- Slider scrubs through seam steps smoothly
- Seam overlays align with actual seam positions
- Energy heatmaps show meaningful gradient structure
- Lattice-space views are rectified correctly
- Seam pairs mode shows ROI compression + pair expansion
- Both bagel and river images work

## Implementation Notes for Future Agent

Before writing the script, you MUST explore the codebase first:
1. Read all files in `src/` to understand the full API (lattice.py, energy.py, seam.py, carving.py)
2. Read `tests/test_lattice.py` to see how functions are called
3. Read any existing files in `examples/`
4. Check what test images exist and their formats
5. Understand tensor shapes and conventions (CHW vs HWC, value ranges, etc.)

Key things to figure out from the source:
- Exact function signatures for `carve_image_lattice_guided`, `carve_seam_pairs`
- How `_interpolate_seam` works and how to map seams back to world space
- The lattice construction API (Lattice2D.rectangular, etc.)
- How energy computation works in lattice space
- What `forward_mapping` and `inverse_mapping` return
